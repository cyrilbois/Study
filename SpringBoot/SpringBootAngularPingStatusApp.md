# Spring Boot with Angular App: Server Ping Status Tracker

Credits / Notes taken from:

- [Spring Boot and Angular Full Stack Development | 4 Hour Youtube Tutorial from AmigosCode](https://www.youtube.com/watch?v=8ZPsZBcue50)
- [Full Stack Spring Boot RESTful API with MySQL and Angular - Youtube Playlist - Direct Source from getarrays.io | Roland Toussaint "Junior"](https://www.youtube.com/playlist?list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf)

<br/>

Table of Contents (ToC):



<br/>

Prerequisites / Needs to be installed:

- [Java](https://www.java.com/en/). Check out my [Study Notes on Java](https://github.com/radualexandrub/Study/blob/master/Java/README.md).
- [Apache Maven (mvn)](https://maven.apache.org/download.cgi).
- [Node.js installed](https://nodejs.org/en/). We need it to use NPM (Node Package Manager) to create an Angular App.
- [Angular](https://angular.io/). Check out my [Study Notes on Angular](https://github.com/radualexandrub/Study/blob/master/Angular/README.md).
- [IntelliJ IDEA (Community or other)](https://www.jetbrains.com/idea/) or [Eclipse IDE](https://www.eclipse.org/ide/).
- [Visual Studio Code](https://code.visualstudio.com/).
- [Postman API Platform](https://www.postman.com/) and [HTTPie â€“ API testing client](https://httpie.io/)... or you can use [Insomnia](https://insomnia.rest/) instead
- [MySQL 8.0 (448MB installer)](https://dev.mysql.com/downloads/installer/)

<br/>

# Backend Spring Boot

## Project Setup

Currently installed on system:

```bash
where java
# C:\Program Files\Java\jdk-17.0.1\bin\java.exe
# C:\Program Files (x86)\Common Files\Oracle\Java\javapath\java.exe

java --version
# java 17.0.1 2021-10-19 LTS
# Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39)
# Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing)

where mvn
# C:\Program Files\apache-maven-3.8.6\bin\mvn
# C:\Program Files\apache-maven-3.8.6\bin\mvn.cmd

mvn --version
# Apache Maven 3.8.6 (84538c9988a25aec085021c365c560670ad80f63)
# Maven home: C:\Program Files\apache-maven-3.8.6
# Java version: 17.0.1, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk-17.0.1
```

Note that `mvn -version` should yield the same Java version value as running `java --version` (Note that Maven takes the Java JDK from the path value within `JAVA_HOME` system environment variable). More info can be found here: https://mkyong.com/maven/maven-error-invalid-target-release-17/

```bash
mysqlsh --version
# C:\Program Files\MySQL\MySQL Shell 8.0\bin\mysqlsh.exe   Ver 8.0.30 for Win64 on x86_64 - for MySQL 8.0.30 (MySQL Community Server (GPL))

docker --version
# Docker version 20.10.13, build a224086

docker-compose --version
# docker-compose version 1.29.2, build 5becea4c
```

<br/>

### Spring Initializr

[Spring Initializr - Initializr generates Spring Boot project with just what you need to start quickly!](https://start.spring.io)

(Thursday, July 06, 2023, 19:32)

Project configuration:

- _Project:_ Maven Project
- _Spring Boot:_ Version 2.7.14 (July 2023)
- _Project Metadata:_
  - _Group (domain):_ "ENTER YOUR DOMAIN HERE" (for me it'll be [com.radubulai](https://radubulai.com))
  - _Artifact (the name of the application):_ serverpingstatustracker
  - _Name:_ serverpingstatustracker
  - _Description:_ Server Ping Status Tracker App with Angular Frontend and Spring Boot API Backend
  - _Package name (you could leave the autogenerated name):_ com.radubulai.serverpingstatustracker
  - _Packaging:_ Jar
  - _Java Version:_ 17

Dependencies:

- **Spring Web** - Build web, including RESTful, applications using Spring MVC. Uses Apache Tomcat as the default embedded container.
- **Spring Data JPA** - Persist data in SQL stores with Java Persistence API using Spring Data and Hibernate (ORM - Object Relational Mappind).
- **MySQL JDBC driver**
- **Validation** `I/O` - Bean Validation with Hibernate validator.
- **Lombok** `DEVELOPER TOOL` - Java annotation library which helps to reduce boilerplate code.


![SpringInitializr](./SpringBootAngularPingStatusApp/SpringInitializr01.jpg)

<br/>

The contents of `pom.xml` file:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.14-SNAPSHOT</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.radubulai</groupId>
    <artifactId>serverpingstatustracker</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>serverpingstatustracker</name>
    <description>Server Ping Status Tracker App with Angular Frontend and Spring Boot API Backend</description>
    <properties>
        <java.version>17</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <repositories>
        <repository>
            <id>spring-milestones</id>
            <name>Spring Milestones</name>
            <url>https://repo.spring.io/milestone</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
        <repository>
            <id>spring-snapshots</id>
            <name>Spring Snapshots</name>
            <url>https://repo.spring.io/snapshot</url>
            <releases>
                <enabled>false</enabled>
            </releases>
        </repository>
    </repositories>
    <pluginRepositories>
        <pluginRepository>
            <id>spring-milestones</id>
            <name>Spring Milestones</name>
            <url>https://repo.spring.io/milestone</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </pluginRepository>
        <pluginRepository>
            <id>spring-snapshots</id>
            <name>Spring Snapshots</name>
            <url>https://repo.spring.io/snapshot</url>
            <releases>
                <enabled>false</enabled>
            </releases>
        </pluginRepository>
    </pluginRepositories>

</project>
```


<br/>

## Server Model, Repository, Service, Controller

![Spring Boot Model Repository Service Controller Schema](./SpringBootAngularPingStatusApp/Spring_Model_Repo_Service_Controller_Schema.jpg)

### Server Model - Data representation

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 2](https://www.youtube.com/watch?v=97IZT1Sires&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=2)

To create a first model class, we right click on our main project package -> New -> Package -> "model".

Inside our "model" package, we right click -> New -> New Java Class -> `Server`.

Our server model will have the following fields (for now):

```java
// /model/Server.java
import com.radubulai.serverpingstatustracker.enumeration.Status;

import java.io.Serializable;

/**
 * @author Radu-Alexandru Bulai (https://radubulai.com)
 * @version 1.0
 * @since 06/07/2023
 */
public class Server implements Serializable {
    private Long id;
    private String ipAddress;
    private String name;
    private String network;
    private Status status;
}
```

> Note: Importing the `Serializable` interface in the `Server` class allows instances of the class to be serialized and deserialized. Serialization is the process of converting an object into a byte stream, which can be stored in a file or transmitted over a network. Deserialization is the reverse process, where the byte stream is converted back into an object. The `Serializable` interface itself doesn't require implementing any methods. It serves as a marker interface, indicating that the class is serializable. This `Server` class can be serialized because all its fields (`id`, `ipAddress`, `name`, `network`, and `status`) are serializable or primitive types.

<br/>

Now we create another `enumeration` package, and `Status.java` inside:

```java
// /enumeration/Status.java
package com.radubulai.serverpingstatustracker.enumeration;

public enum Status {
    SERVER_UP("SERVER_UP"),
    SERVER_DOWN("SERVER_DOWN");

    private final String status;

    Status(String status) {
        this.status = status;
    }

    public String getStatus() {
        return this.status;
    }
}
```

<br/>

Now we want this class to be in a database - that's why we added [_"Spring Data JPA (Java Persistence API)"_](https://spring.io/projects/spring-data-jpa):

- We first add the `@Entity` annotation from *Java Persistence API (JPA)*. This marks the class as an entity, representing a table in a relational database. It indicates that instances of the Server class can be persisted and managed by an ORM (Object-Relational Mapping) framework, such as Hibernate.
- We need to set our "PRIMARY KEY", for this we add `@Id` decorator. We also need to tell it how to generate this ID, so we add `@GeneratedValue(strategy = AUTO)`: This JPA annotation specifies the generation strategy for the `id` field. In this case, the value is set to `AUTO`, which means that the persistence provider (e.g., Hibernate) will determine the most appropriate strategy for generating the primary key values.
- `@Column(unique = true)`: This JPA annotation specifies that the `ipAddress` field should be mapped to a database column, and the `unique` attribute indicates that the values in this column must be unique. It ensures that each `Server` entity has a distinct IP address in the corresponding database column.

Note: from the "Lombok" library we'll use the following decorators:
- `@Data`: This Lombok annotation generates boilerplate code for common methods such as getters, setters, `equals()`, `hashCode()`, and `toString()`. It helps reduce the verbosity of the code by automatically generating these methods based on the class's fields.
- `@NoArgsConstructor`: This Lombok annotation generates a no-argument constructor for the `Server` class. It allows frameworks like JPA to create instances of the class without having to provide constructor arguments explicitly. This constructor is useful in scenarios such as object instantiation through reflection or object population through deserialization.
- `@AllArgsConstructor`: This Lombok annotation generates a constructor with parameters for all fields in the `Server` class. It provides a convenient way to initialize all the fields in a single constructor call. This constructor can be useful when creating instances of the class manually or when mapping data from external sources to the `Server` class, and `status`) are serializable or primitive types.

Note: from the "Validation" (Hibernate Validator library) library we'll use the following:
- `@NotEmpty(message = "IP Address cannot be empty or null")` indicates that the `ipAddress` field must not be empty or null. If an empty or null value is encountered during validation, a validation error with the specified message will be generated.

```java
// /model/Server.java
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Server implements Serializable {
    @Id
    @GeneratedValue(strategy = AUTO)
    private Long id;
    @Column(unique = true)
    @NotEmpty(message = "IP Address cannot be empty or null")
    private String ipAddress;
    private String name;
    private String network;
    private Status status;
}
```

![Ping Status Tracker Model](./SpringBootAngularPingStatusApp/Model01.jpg)

![Spring Lombok vs Implementation](./SpringBootAngularPingStatusApp/Model02.jpg)

<br/>

### Server Repository - CRUD Operations in Database

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 3](https://www.youtube.com/watch?v=SuWTVgRJG94&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=3)

All the CRUD (Create, Read, Update, Delete) operations will be created under a "Server Repository" Java package (`repository`).

For the `repository` package:

- On our main project package -> create a new package called `repository`
- Inside `repository` package, we create a Java Interface called `ServerRepository`
- This interface `ServerRepository` will extend the `JpaRepository`. Also, when extending from `JpaRepository` interface, we need to specify the model type (`Server`) and the ID data type (`Long`): `public interface ServerRepository extends JpaRepository<Server, Long>`.

> Note: We can CTRL+Click on `JpaRepository` interface to see its decompilled .class file (its code), and look over its methods, eg: `findAll`, `saveAll`, `deleteAllInBatch`, etc... (those are useful methods as we don't need to implement them from scratch)

<br/>

We are going to use the default methods that are already implemented in the JpaRepository in order to manipulate the data within the database (create Servers, or delete Servers, etc).

However, we will create one additional custom method in order to find a Server entry by its IP Address: `Server findByIpAddress(String ipAddress);` _(or `findServerByIpAddress`, either way is correct)_ - the equivalent MySQL query for this JPA Entity Mapping would be `SELECT * FROM Server WHERE ipAddress = <ipAddress>;`.

> More notes: The process behind "translating `Server findByIpAddress(String ipAddress);` in SQL and returning the `Server` Java Object:
> 
> 1.  JPA Entity Mapping: Assuming you have properly configured JPA with Hibernate or any other JPA implementation, and you have mapped the `Server` class to a corresponding table in the database, JPA will handle the mapping between the Java object and the database table.
> 
> 2.  Repository Interface: In JPA, you typically define a repository interface that extends `JpaRepository<Server, Long>` or a similar interface. This interface provides various methods for performing CRUD (Create, Read, Update, Delete) operations on the entity.
> 
> 3.  Method Declaration: By defining the method `findByIpAddress(String ipAddress)` in the repository interface, you are specifying a custom query method. JPA will automatically generate the SQL query based on the method name and the rules defined in Spring Data JPA.
> 
> 4.  SQL Generation: When the application starts up, Spring Data JPA analyzes the method name and parses it to determine the query's intent. In this case, the method name follows the naming convention of `findBy<PropertyName>`. So, Spring Data JPA understands that you want to find a `Server` object based on its `ipAddress` property.
> 
> 5.  Query Execution: At runtime, when you invoke the `findByIpAddress()` method with a specific `ipAddress` parameter, Spring Data JPA generates the SQL query mentioned above. It replaces `<ipAddress>` with the actual parameter value and executes the query against the underlying MySQL database.
> 
> 6.  Result Mapping: Once the query is executed, the database returns the result set, which consists of rows that match the specified `ipAddress`. Spring Data JPA maps the result set to the `Server` entity class and returns the corresponding Java object or objects.
> 
> In summary, the process involves the JPA entity mapping, defining a repository interface with the custom query method, SQL generation based on the method name, execution of the generated query, and mapping the query result back to Java objects. This allows you to easily perform database operations using familiar Java methods and have JPA handle the underlying SQL queries and result mapping for you.
> 
> <hr/>
> 
> Why JpaRepository is called "repository"?
> 
> The term "repository" in the context of Spring Data JPA refers to a pattern commonly used in software development for providing a standardized way to interact with a data source, such as a database. The repository pattern abstracts the underlying data access operations and provides a higher-level interface for working with data.
> 
> In the case of Spring Data JPA, the `JpaRepository` interface is an implementation of the repository pattern specifically designed for JPA (Java Persistence API). It combines the features of the repository pattern with the capabilities of JPA to simplify data access and provide a consistent interface for CRUD operations.

<br/>

```java
// ServerRepository.java
package com.radubulai.serverpingstatustracker.repository;

import com.radubulai.serverpingstatustracker.model.Server;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface ServerRepository extends JpaRepository<Server, Long> {

    Server findByIpAddress(String ipAddress);
    void deleteServerById(Long id);
    Optional<Server> findServerById(Long id);
}
```

<br/>

### Server Service - Business logic and application workflow

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 4](https://www.youtube.com/watch?v=TdL-QKKKBc4&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=4)

So far we have the `Server Model` (data representation) and the `Server Repository` in order to manipulate the data (through CRUD operations in the SQL database). Next we will define the `Server Service` for the different features (or data processing within Java backend - Business logic) that we want to have in our application.

For the `service` package:

- On our main/base project package -> create a new package called `service`
- Inside `service` package, create a new Java **Interface** called `ServerServiceI`
- Here in `ServerServiceI` we can define all our of methods that we will want to implement, such as:
    - retrieving all Servers from database: `Collection<Server> findAllServer();`
    - adding/creating a Server in database: `Server addServer(Server server);`
    - updating a Server in database: `Server updateServer(Server server);`
    - deleting a Server in database: `void deleteServer(Long id);`
    - pinging a server in database: `Server ping(String ipAddress);`

```java
// ServerServiceI.java
package com.radubulai.serverpingstatustracker.service;

import com.radubulai.serverpingstatustracker.model.Server;
import com.radubulai.serverpingstatustracker.repository.ServerRepository;

import java.util.Collection;

public interface ServerServiceI {

    Collection<Server> findAllServers();

    Server addServer(Server server);

    Server updateServer(Server server);

    void deleteServer(Long id);

    Server pingServer(String ipAddress);
}
```

<br/>

- Inside `service` package we can create another `implementation` package, and here we'll have the `ServerServiceImpl.java` class
    - Inside `ServerServiceImpl.java`, we create a `ServerRepository` object where we will use the defined SQL / Query methods
    - Now, usually after declaring this `serverRepository` object, we needed to initialize it by calling the `public ServerServiceImpl(ServerRepository serverRepository) { this.serverRepository = serverRepository; }` constructor - however, since we use the Lombok library, we can simply add the `@RequiredArgsConstructor` annotation
    - We also need to annotate the `ServerService` class repo with `@Service` decorator

```java
// ServerServiceImpl.java
package com.radubulai.serverpingstatustracker.service.implementation;

@Service
@RequiredArgsConstructor
@Transactional
@Slf4j
public class ServerServiceImpl implements ServerServiceI {
    private final ServerRepository serverRepository;
}
```

> Notes on the annotations used:
> - `@Service`: This annotation is from the Spring Framework and is used to mark a class as a service component. It indicates that the class contains the business logic of the application. By annotating the class with `@Service`, it becomes eligible for auto-detection and can be injected into other Spring components, such as controllers.
> - `@RequiredArgsConstructor`: This is a Lombok annotation that automatically generates a constructor with required arguments based on the class's final fields. In this case, since the `ServerRepository` field is marked as `final`, Lombok generates a constructor that accepts an instance of `ServerRepository` and assigns it to the field. This eliminates the need for explicitly defining a constructor in the class.
> - `@Transactional`: This annotation is from the Spring Framework and is used to define the transactional behavior of a method or class. By annotating the class with `@Transactional`, all public methods in the class become transactional. Transactions ensure data consistency and integrity by enforcing ACID (Atomicity, Consistency, Isolation, Durability) properties when performing database operations.
> - `@Slf4j`: This annotation is from Lombok and is used to generate a logger field in the class. It automatically creates a logger instance with the name "log" that can be used for logging messages within the class. The logging framework used depends on the project's configuration.

<br/>

Now, we can define all of our business operations, such as:

1\) `pingServer(String ipAddress)`

```java
public Server pingServer(String ipAddress) throws IOException {
    log.info("Pinging Server IP {}", ipAddress);
    int IS_REACHABLE_TIMEOUT_IN_MILLIS = 10000;
    Server server = serverRepository.findByIpAddress(ipAddress);
    InetAddress inetAddress = InetAddress.getByName(ipAddress);
    server.setStatus(inetAddress.isReachable(IS_REACHABLE_TIMEOUT_IN_MILLIS) ? SERVER_UP : SERVER_DOWN);
    serverRepository.save(server);
    return server;
}
```

- retrieves a `Server` object from the `serverRepository` by calling `findByIpAddress` (JPA Entity Mapping of `SELECT * FROM Server WHERE ipAddress = <ipAddress>;` SQL query)
- uses the `InetAddress.getByName` method to obtain an `InetAddress` object corresponding to the given `ipAddress`. This allows the function to perform network-related operations using the IP address.
- sets the status of the `Server` object based on whether the IP address is reachable. If the IP address is reachable within the given timeout, it sets the server's status to "SERVER_UP". Otherwise, it sets the status to "SERVER_DOWN".sets the status of the `Server` object based on whether the IP address is reachable. If the IP address is reachable within the given timeout, it sets the server's status to "SERVER_UP". Otherwise, it sets the status to "SERVER_DOWN".
- saves to database and returns the updated Server object

<br/>

2\) `findAllServers()`

```java
public Collection<Server> findAllServers(int limit) {
    log.info("Fetching {} servers", limit);
    return serverRepository.findAll(PageRequest.of(0, limit)).toList();
}
```

- retrieves a collection of `Server` objects from the `serverRepository` by calling the `findAll` method with a `PageRequest` object. The `PageRequest.of(0, limit)` method creates a `PageRequest` object that specifies the page number (`0` indicates the first page) and the number of results to fetch (`limit` represents the maximum number of servers to fetch)
- returns the collection of `Server` objects

<br/>

3\) `addServer(Server server)`
- return the returned `Server` object from calling the JPA Repository `save` method: `return serverRepository.save(server);` that has an equivalent query of `INSERT INTO servers (column1, column2, column3, ...) VALUES (value1, value2, value3, ...)`

```java
public Server addServer(Server server) {
    log.info("Saving Server {}", server);
    return serverRepository.save(server);
}
```

<br/>

4\) `updateServer(Server server)`
- return `Server` object from the `save` JPA (and underlying JPA provider - e.g. Hibernate) method with the equivalent query of `UPDATE servers SET column1 = value1, column2 = value2, column3 = value3, ... WHERE id = serverId`

```java
public Server updateServer(Server server) {
    log.info("Updating Server {}", server);
    return serverRepository.save(server);
}
```

<br/>

5\) `deleteServerById(Long id)`
- since we can't use `serverRepo.delete(id);` because the `delete` method from inherited JPA Repo does not accept any `Long` type parameter (as an ID), we will need to create our own `serverRepo.deleteserverById(id);` inside `/repo/serverRepo.java`

```java
public void deleteServerById(Long id) {
    log.info("Deleting Server with id={}", id);
    serverRepository.deleteServerById(id);
}
```

<br/>

6\) `findServerById(Long id)`
- `findServerById(Long id)` needs to be defined in the `ServerRepository` (returns `Optional<Server>`)
- if no server is found by id in db, do not return anything - throw a `ServerNotFoundException` instead (using `orElseThrow` Java8 method that receives a Java8 lambda function as parameter)
- we define `ServerNotFoundException` (that inherits `RuntimeException`) separatedly in a package `exception` in `ServerNotFoundExeption.java`

```java
// ServerServiceImpl.java
public Server findServerById(Long id) {
    log.info("Fetching server with id={}", id);
    return serverRepository.findServerById(id).orElseThrow(
            () -> new ServerNotFoundException("Server by id " + id + " was not found")
    );
}
```

```java
// ServerNotFoundExeption.java
package com.radubulai.serverpingstatustracker.exception;

public class ServerNotFoundException extends RuntimeException {
    public ServerNotFoundException(String message) {
        super(message);
    }
}
```

```java
// ServerRepository.java
public interface ServerRepository extends JpaRepository<Server, Long> {

    Server findServerByIpAddress(String ipAddress);
    void deleteServerById(Long id);
    Optional<Server> findServerById(Long id);
}
```

<br/>

Complete code from `ServerServiceImpl.java`:

```java
// ServerServiceImpl.java
package com.radubulai.serverpingstatustracker.service.implementation;

import com.radubulai.serverpingstatustracker.exception.ServerNotFoundException;
import com.radubulai.serverpingstatustracker.model.Server;
import com.radubulai.serverpingstatustracker.repository.ServerRepository;
import com.radubulai.serverpingstatustracker.service.ServerServiceI;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import javax.transaction.Transactional;
import java.io.IOException;
import java.net.InetAddress;
import java.util.Collection;

import static com.radubulai.serverpingstatustracker.enumeration.Status.*;

@Service
@RequiredArgsConstructor
@Transactional
@Slf4j
public class ServerServiceImpl implements ServerServiceI {
    private final ServerRepository serverRepository;

    @Override
    public Collection<Server> findAllServers() {
        return serverRepository.findAll();
    }

    public Collection<Server> findAllServers(int limit) {
        log.info("Fetching {} servers", limit);
        return serverRepository.findAll(PageRequest.of(0, limit)).toList();
    }

    public Page<Server> findAllServers(int pageNumber, int pageSize) {
        log.info("Fetching {} servers (Page {})", pageSize, pageNumber);
        Pageable pageable = PageRequest.of(pageNumber, pageSize);
        return serverRepository.findAll(pageable);
    }

    public Server findServerById(Long id) {
        log.info("Fetching server with id={}", id);
        return serverRepository.findServerById(id).orElseThrow(
                () -> new ServerNotFoundException("Server by id " + id + " was not found")
        );
    }

    @Override
    public Server addServer(Server server) {
        log.info("Saving Server {}", server);
        return serverRepository.save(server);
    }

    @Override
    public Server updateServer(Server server) {
        log.info("Updating Server {}", server);
        return serverRepository.save(server);
    }

    @Override
    public void deleteServerById(Long id) {
        log.info("Deleting Server with id={}", id);
        serverRepository.deleteServerById(id);
    }

    @Override
    public Server pingServer(String ipAddress) throws IOException {
        log.info("Pinging Server with ipAddress={}", ipAddress);
        int IS_REACHABLE_TIMEOUT_IN_MILLIS = 10000;
        Server server = serverRepository.findServerByIpAddress(ipAddress);
        InetAddress inetAddress = InetAddress.getByName(ipAddress);
        server.setStatus(inetAddress.isReachable(
            IS_REACHABLE_TIMEOUT_IN_MILLIS) ? SERVER_UP : SERVER_DOWN);
        serverRepository.save(server);
        return server;
    }
}
```

(Saturday, July 08, 2023, 00:46)

<br/>

### (Optional) Response Model for each response from API

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 8](https://www.youtube.com/watch?v=yh2ZlJJ0jXg&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=8)

Before implementing the Controller, we can create a `Response` class (under `model` package) that we can send back to the end user (browser) no matter the response to the request is an error or a succesfull retrieve/update/etc of data. The `Response` will include several properties such as:
- `timeStamp`
- `statusCode` (the numerical status code)
- `status` (the corresponding `HttpStatus` enum value from Spring Framework, e.g. `OK` for 200, `CREATED` for 201, `MOVED_PERMANENTLY` for 301, `FOUND` for 302, `BAD_REQUEST` for 400, `UNAUTHORIZED` for 401, `NOT_FOUND` for 404, `INTERNAL_SERVER_ERROR` for 500, etc.)
- `reason` (a descriptive reason for the response)
- `message` (a human-readable message that can be shown to the end user)
- `developerMessage` (a more technical message for developers or for debugging purposes)
- `data`

Note, by default, if we do not implement such class, every response that our API will send will be the direct JSON data (and other details will be found in the header of the HTTP request).

```java
package com.radubulai.serverpingstatustracker.model;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Data;
import lombok.experimental.SuperBuilder;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
import java.util.Map;

@Data
@SuperBuilder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class Response {
    protected LocalDateTime timeStamp;
    protected int statusCode;
    protected HttpStatus status;
    protected String reason;
    protected String message;
    protected String developerMessage;
    protected Map<?, ?> data;
}
```

Annotations from above:
- `@Data` annotation from Lombok library generates boilerplate code for common methods such as getters, setters, `equals()`, `hashCode()`, and `toString()`
- `@SuperBuilder` annotation from Lombok library allows for a fluent builder API for constructing instances of the `Response` class (see below its usage in ServerResource controller).
- `@JsonInclude(JsonInclude.Include.NON_NULL)` annotation from the Jackson library ensures that properties with null values are not included in the JSON serialization - it helps in producing a more concise and clean JSON response

<br/>

#### HTTP Status codes from Spring HttpStatus enum

`org.springframework.http.HttpStatus.class`

| Value | HttpStatus.Series | Reason Phrase |
| --- | --- | --- |
| 100 | INFORMATIONAL | Continue |
| 101 | INFORMATIONAL | Switching Protocols |
| 102 | INFORMATIONAL | Processing |
| 103 | INFORMATIONAL | Checkpoint |
| 200 | SUCCESSFUL | OK |
| 201 | SUCCESSFUL | Created |
| 202 | SUCCESSFUL | Accepted |
| 203 | SUCCESSFUL | Non-Authoritative Information |
| 204 | SUCCESSFUL | No Content |
| 205 | SUCCESSFUL | Reset Content |
| 206 | SUCCESSFUL | Partial Content |
| 207 | SUCCESSFUL | Multi-Status |
| 208 | SUCCESSFUL | Already Reported |
| 226 | SUCCESSFUL | IM Used |
| 300 | REDIRECTION | Multiple Choices |
| 301 | REDIRECTION | Moved Permanently |
| 302 | REDIRECTION | Found |
| 303 | REDIRECTION | See Other |
| 304 | REDIRECTION | Not Modified |
| 307 | REDIRECTION | Temporary Redirect |
| 308 | REDIRECTION | Permanent Redirect |
| 400 | CLIENT_ERROR | Bad Request |
| 401 | CLIENT_ERROR | Unauthorized |
| 402 | CLIENT_ERROR | Payment Required |
| 403 | CLIENT_ERROR | Forbidden |
| 404 | CLIENT_ERROR | Not Found |
| 405 | CLIENT_ERROR | Method Not Allowed |
| 406 | CLIENT_ERROR | Not Acceptable |
| 407 | CLIENT_ERROR | Proxy Authentication Required |
| 408 | CLIENT_ERROR | Request Timeout |
| 409 | CLIENT_ERROR | Conflict |
| 410 | CLIENT_ERROR | Gone |
| 411 | CLIENT_ERROR | Length Required |
| 412 | CLIENT_ERROR | Precondition Failed |
| 413 | CLIENT_ERROR | Payload Too Large |
| 414 | CLIENT_ERROR | URI Too Long |
| 415 | CLIENT_ERROR | Unsupported Media Type |
| 416 | CLIENT_ERROR | Requested range not satisfiable |
| 417 | CLIENT_ERROR | Expectation Failed |
| 418 | CLIENT_ERROR | I'm a teapot |
| 419 | CLIENT_ERROR | Insufficient Space On Resource |
| 420 | CLIENT_ERROR | Method Failure |
| 421 | CLIENT_ERROR | Destination Locked |
| 422 | CLIENT_ERROR | Unprocessable Entity |
| 423 | CLIENT_ERROR | Locked |
| 424 | CLIENT_ERROR | Failed Dependency |
| 425 | CLIENT_ERROR | Too Early |
| 426 | CLIENT_ERROR | Upgrade Required |
| 428 | CLIENT_ERROR | Precondition Required |
| 429 | CLIENT_ERROR | Too Many Requests |
| 431 | CLIENT_ERROR | Request Header Fields Too Large |
| 451 | CLIENT_ERROR | Unavailable For Legal Reasons |
| 500 | SERVER_ERROR | Internal Server Error |
| 501 | SERVER_ERROR | Not Implemented |
| 502 | SERVER_ERROR | Bad Gateway |
| 503 | SERVER_ERROR | Service Unavailable |
| 504 | SERVER_ERROR | Gateway Timeout |
| 505 | SERVER_ERROR | HTTP Version not supported |
| 506 | SERVER_ERROR | Variant Also Negotiates |
| 507 | SERVER_ERROR | Insufficient Storage |
| 508 | SERVER_ERROR | Loop Detected |
| 509 | SERVER_ERROR | Bandwidth Limit Exceeded |
| 510 | SERVER_ERROR | Not Extended |
| 511 | SERVER_ERROR | Network Authentication Required |

<br/>

### Server Controller/Resource - HTTP requests handling, Exposing the API

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 9](https://www.youtube.com/watch?v=sY2oO9oh1BE&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=9)

For a newly created `resource` package:
- We can create a `ServerResource.java` class (resource is a more usual term for the RESTful API Design Methodology - we could have call it `ServerController.java` instead)
- Add the following annotations:
    - `@RestController`: This annotation is from the Spring Framework and combines the `@Controller` and `@ResponseBody` annotations. It marks the class as a RESTful controller, indicating that the class will handle incoming HTTP requests and produce HTTP responses. The `@RestController` annotation is typically used in Spring MVC or Spring WebFlux applications.
    - `@RequestMapping("/api/servers")`: This annotation is from the Spring Framework and is used to map incoming requests to specific handler methods in the controller. It defines the base URL ("/api/servers") that this controller will handle. In this case, any request that starts with "/api/servers" will be directed to methods within this class for further processing.
    - `@RequiredArgsConstructor`: This annotation is from the Lombok library and generates a constructor with required arguments for the `ServerResource` class. Since `ServerServiceImpl` is a required dependency for `ServerResource`, Lombok generates a constructor that accepts an instance of `ServerServiceImpl` and assigns it to the `serverService` field. This annotation eliminates the need to explicitly write the constructor code.

![Server Resource](./SpringBootAngularPingStatusApp/Resource01.jpg)

(Saturday, July 08, 2023, 23:41)

<br/>

1\) **getAllServers**

```java
@RestController
@RequestMapping("/api/servers")
@RequiredArgsConstructor
public class ServerResource {
    private final ServerServiceImpl serverService;

    @GetMapping("")
    public ResponseEntity<Response> getAllServers() {
        return ResponseEntity.ok(
                Response.builder()
                        .timeStamp(now())
                        .data(Map.of("servers", serverService.findAllServers()))
                        .message("Servers retrieved")
                        .status(OK)
                        .statusCode(OK.value())
                        .build());
    }
}
```

- `@GetMapping("")`: Spring Framework annotation that maps the function to handle GET requests on the base URL ("/api/servers"). The empty string within the `@GetMapping` annotation indicates that the function will handle GET requests to the base URL itself.
- `public ResponseEntity<Response> getAllServers()`: returns a `ResponseEntity<Response>` object, which represents the HTTP response that will be sent back to the client. The `Response` class is a custom class that encapsulates the response data.
- `ResponseEntity.ok(...)`: method is used to create a `ResponseEntity` object with an HTTP status of 200 (OK). It indicates that the request was successful, and the response will contain the desired data.
- `Response.builder()`: uses the builder pattern (from Lombok library) to create a new `Response` object.
- `.timeStamp(now())`: sets the `timeStamp` property of the `Response` object to the current timestamp.
- `.data(Map.of("servers", serverService.findAllServers()))`: sets the `data` property of the `Response` object to a map containing a single key-value pair. The key is "servers" and the value is the result of calling the `findAllServers()` method on the `serverService` instance.
- `.message("Servers retrieved")`: sets the `message` property of the `Response` object to "Servers retrieved". It provides a human-readable message indicating the purpose of the response.
- `.status(OK)`: sets the `status` property of the `Response` object to the `HttpStatus.OK` enum value, indicating that the request was successful.
- `.statusCode(OK.value())`: sets the `statusCode` property of the `Response` object to the numerical value of the `HttpStatus.OK` enum, which is 200.
- `.build()`: builds the final `Response` object using the configured properties and returns it.

<br/>


2\) **pingServer**

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 10](https://www.youtube.com/watch?v=ngFKEGmV2Ik&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=10)

The `pingServer` function handles a GET request to ping a server with a specified IP address. It calls the `pingServer` method on the `serverService` instance, retrieves the server object, and constructs a `Response` object containing the server data, timestamp, and a message indicating the success or failure of the ping operation. The response is wrapped in a `ResponseEntity` object with an HTTP status of 200 (OK) and returned to the client.

```java
@GetMapping("/ping/{ipAddress}")
public ResponseEntity<Response> pingServer(
        @PathVariable("ipAddress") String ipAddress) throws IOException {
    Server server = serverService.pingServer(ipAddress);
    return ResponseEntity.ok(
            Response.builder()
                    .timeStamp(now())
                    .data(Map.of("server", server))
                    .message(server.getStatus() == SERVER_UP ? "Ping success" : "Ping failed")
                    .status(OK)
                    .statusCode(OK.value())
                    .build());
}
```

1.  `@GetMapping("/ping/{ipAddress}")`: annotation from the Spring Framework that maps the function to handle GET requests on the URL "/api/servers/ping/{ipAddress}". The `{ipAddress}` is a path variable that will be dynamically replaced with the actual IP address provided in the URL.
2.  `public ResponseEntity<Response> pingServer(@PathVariable("ipAddress") String ipAddress) throws IOException`: handles the GET request and expects a path variable named "ipAddress" to be provided in the URL. The value of the path variable will be passed as the `ipAddress` parameter of the function. It also specifies that the function may throw an `IOException`.
3.  `Server server = serverService.pingServer(ipAddress)`: line calls the `pingServer` method on the `serverService` instance, passing the `ipAddress` parameter. It retrieves a `Server` object representing the server with the specified IP address.
4.  `ResponseEntity.ok(...)`: is used to create a `ResponseEntity` object with an HTTP status of 200 (OK). It indicates that the request was successful, and the response will contain the desired data.
5.  `Response.builder()`: starts building a new `Response` object using the builder pattern.
6.  `.timeStamp(now())`: sets the `timeStamp` property of the `Response` object to the current timestamp.
7.  `.data(Map.of("server", server))`: sets the `data` property of the `Response` object to a map containing a single key-value pair. The key is "server," and the value is the `server` object obtained from the `serverService.pingServer` method.
8.  `.message(server.getStatus() == SERVER_UP ? "Ping success" : "Ping failed")`: sets the `message` property of the `Response` object based on the status of the `server` object. If the server status is `SERVER_UP`, the message is set to "Ping success"; otherwise, it is set to "Ping failed".
9.  `.status(OK)`: sets the `status` property of the `Response` object to the `HttpStatus.OK` enum value, indicating that the request was successful.
10. `.statusCode(OK.value())`: sets the `statusCode` property of the `Response` object to the numerical value of the `HttpStatus.OK` enum, which is 200.
11. `.build()`: builds the final `Response` object using the configured properties and returns it.




<br/>

3\) **addServer**

The `addServer` method handles an HTTP POST request to create a new server. It validates the request payload, adds the server using the `serverService.addServer` method, and constructs a `Response` object containing the server data, timestamp, and a success message. The response is wrapped in a `ResponseEntity` object with an HTTP status of 200 (OK) and returned to the client.

```java
@PostMapping("")
public ResponseEntity<Response> addServer(@RequestBody @Valid Server server) {
    return ResponseEntity.ok(
            Response.builder()
                    .timeStamp(now())
                    .data(Map.of("server", serverService.addServer(server)))
                    .message("Server created")
                    .status(CREATED)
                    .statusCode(CREATED.value())
                    .build());
}
```

1.  `public ResponseEntity<Response> addServer(@RequestBody @Valid Server server)`: method expects a **JSON payload** representing a `Server` object in the request body. The `@RequestBody` annotation binds the request body to the `server` parameter. The `@Valid` annotation validates the `Server` object using the specified validation constraints (e.g., from the ServerModel - `@Column(unique = true) @NotEmpty(message = "IP Address cannot be empty or null") private String ipAddress;`).
2.  `ResponseEntity.ok(...)`: method is used to create a `ResponseEntity` object with an HTTP status of 200 (OK). It indicates that the request was successful, and the response will contain the desired data. Note that if we used `create` it would not let us return back the Server object that was added to database.
3.  `Response.builder()`: starts building a new `Response` object using the builder pattern.
4.  `.timeStamp(now())`: sets the `timeStamp` property of the `Response` object to the current timestamp.
5.  `.data(Map.of("server", serverService.addServer(server)))`: sets the `data` property of the `Response` object to a map containing a single key-value pair. The key is "server," and the value is the `server` object obtained from the `serverService.addServer` method, which adds the server to the system.
6.  `.message("Server created")`: sets the `message` property of the `Response` object to "Server created". It provides a human-readable message indicating the successful creation of the server.
7.  `.status(CREATED)`: sets the `status` property of the `Response` object to the `HttpStatus.CREATED` enum value
8.  `.statusCode(CREATED.value())`: sets the `statusCode` property of the `Response` object to the numerical value of the `HttpStatus.CREATED` enum, which is 201.
9.  `.build()`: builds the final `Response` object using the configured properties and returns it.


<br/>

4\) **getServerById**

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 11](https://www.youtube.com/watch?v=-ZcJLE2mcR8&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=11)

```java
@GetMapping("/{id}")
public ResponseEntity<Response> getServerById(@PathVariable Long id) {
    return ResponseEntity.ok(
            Response.builder()
                    .timeStamp(now())
                    .data(Map.of("server", serverService.findServerById(id)))
                    .message("Server retrieved")
                    .status(OK)
                    .statusCode(OK.value())
                    .build());
}
```


<br/>

5\) **deleteServerById**

Deletes a server by sending a DELETE request to the `/api/servers/{id}` endpoint, where `{id}` is the identifier of the server to be deleted.

```java
@DeleteMapping("/{id}")
public ResponseEntity<Response> deleteServerById(@PathVariable Long id) {
    return ResponseEntity.ok(
            Response.builder()
                    .timeStamp(now())
                    .data(Map.of("deleted", serverService.deleteServerById(id)))
                    .message("Server deleted")
                    .status(OK)
                    .statusCode(OK.value())
                    .build());
}
```

<br/>

<br/>

Complete code (so far) for `ServerResource.java` (Sunday, July 09, 2023, 00:38)

```java
package com.radubulai.serverpingstatustracker.resource;

import com.radubulai.serverpingstatustracker.model.Response;
import com.radubulai.serverpingstatustracker.model.Server;
import com.radubulai.serverpingstatustracker.service.implementation.ServerServiceImpl;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.io.IOException;
import java.util.Map;

import static com.radubulai.serverpingstatustracker.enumeration.Status.*;
import static java.time.LocalDateTime.*;
import static org.springframework.http.HttpStatus.CREATED;
import static org.springframework.http.HttpStatus.OK;

/**
 * @author Radu-Alexandru Bulai (<a href="https://radubulai.com">https://radubulai.com</a>)
 * @version 1.0
 * @since 08/07/2023
 */
@RestController
@RequestMapping("/api/servers")
@RequiredArgsConstructor
public class ServerResource {
    private final ServerServiceImpl serverService;

    @GetMapping("")
    public ResponseEntity<Response> getAllServers() {
        return ResponseEntity.ok(
                Response.builder()
                        .timeStamp(now())
                        .data(Map.of("servers", serverService.findAllServers()))
                        .message("Servers retrieved")
                        .status(OK)
                        .statusCode(OK.value())
                        .build());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Response> getServerById(@PathVariable Long id) {
        return ResponseEntity.ok(
                Response.builder()
                        .timeStamp(now())
                        .data(Map.of("server", serverService.findServerById(id)))
                        .message("Server retrieved")
                        .status(OK)
                        .statusCode(OK.value())
                        .build());
    }

    @PostMapping("")
    public ResponseEntity<Response> addServer(@RequestBody @Valid Server server) {
        return ResponseEntity.ok(
                Response.builder()
                        .timeStamp(now())
                        .data(Map.of("server", serverService.addServer(server)))
                        .message("Server created")
                        .status(CREATED)
                        .statusCode(CREATED.value())
                        .build());
    }

    @PutMapping("")
    public ResponseEntity<Response> updateServer(@RequestBody @Valid Server server) {
        return ResponseEntity.ok(
                Response.builder()
                        .timeStamp(now())
                        .data(Map.of("server", serverService.updateServer(server)))
                        .message("Server updated")
                        .status(OK)
                        .statusCode(OK.value())
                        .build());
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Response> deleteServerById(@PathVariable Long id) {
        return ResponseEntity.ok(
                Response.builder()
                        .timeStamp(now())
                        .data(Map.of("deleted", serverService.deleteServerById(id)))
                        .message("Server deleted")
                        .status(OK)
                        .statusCode(OK.value())
                        .build());
    }

    @GetMapping("/ping/{ipAddress}")
    public ResponseEntity<Response> pingServer(
            @PathVariable("ipAddress") String ipAddress) throws IOException {
        Server server = serverService.pingServer(ipAddress);
        return ResponseEntity.ok(
                Response.builder()
                        .timeStamp(now())
                        .data(Map.of("server", server))
                        .message(server.getStatus() == SERVER_UP ? "Ping success" : "Ping failed")
                        .status(OK)
                        .statusCode(OK.value())
                        .build());
    }
}
```

<br/>

Note on July 10, 2023, 22:00: Additional methods were added:
- `public Server pingServer(Long id) throws IOException` - that finds the server by its id then pings it
- `public Collection<Server> pingAllServers() throws IOException` - retrieves all the servers then pings each one of them, returns the list of servers with all statuses updated (Note: could take long until the list is received on client browser)
- `public Status pingServerOnly(String ipAddress) throws IOException` - only pings server specified in URL `@GetMapping("/ping/{ipAddress}")` and returns its status (does not query the database)

<br/>

## Database configuration

After installing [MySQL 8.0 (448MB installer)](https://dev.mysql.com/downloads/installer/), we can open "MySQL 8.0 Command Line Client" (from Windows Start Menu).

ðŸ”µ Note: *(On Windows)* If we cannot start the MySQL Server (eg. "MySQL Workbench" just crashes when we try to start the server):
-   Open Windows Start Menu, search and open "Services", manually find `MySQL80` service -> Right click it -> Start.
-   (does not work in my case) We can just run (as administrator) the executable from `C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld.exe`.
-   See more here: [Can't startup and connect to MySQL server](https://stackoverflow.com/questions/31387036/cant-startup-and-connect-to-mysql-server).

<br/>

> Alternative: Using MySQL Docker image instead of installing MySQL 8.0 Server *on Linux (or Windows)* PC
> - Install [Docker](https://www.docker.com/). 
> - *(In Linux)* Check if Docker service is running by `systemctl status docker` (use `systemctl start docker` if service is not running)
> - Run `sudo docker images -a` to view current images
> - Run `sudo docker pull mysql` to pull the latest MySQL image from https://hub.docker.com/_/mysql
> - Run the below command that will create a MySQL server container with the following configurations:
>   - Container name: mysql-server
>   - Root password: yourpassword
>   - Database name: pingstatustracker
>   - Exposed port: 3306
> 
> ```shell
> sudo docker run -d \
>   --name mysql-server \
>   -e MYSQL_ROOT_PASSWORD=yourpassword \
>   -e MYSQL_DATABASE=pingstatustracker \
>   -p 3306:3306 \
>   mysql:latest \
>   --character-set-server=utf8mb4 \
>   --collation-server=utf8mb4_unicode_ci \
>   --default-authentication-plugin=mysql_native_password \
>   --sql-mode=NO_ENGINE_SUBSTITUTION \
>   --innodb-flush-log-at-trx-commit=0
> ```
>
> - Check if the MySQL container was created with `sudo docker container ls`. You can also check images, containers, cache size with `sudo docker system df`
> - Check if the MySQL container is running with `sudo docker container ls -a`. If MySQL:latest container is up, you can start the Spring Boot Application by running `mvn spring-boot:run` - if application ran with no errors, then the Spring Boot app did successfully connect to MySQL running as docker image!
>
> - You can run `sudo docker exec -it mysql-server mysql -uroot -pyourpassword -D pingstatustracker` to enter the MySQL image and run some INSERT SQL queries, e.g.: `INSERT INTO server (id, ip_address, name, network, status) VALUES (1, '8.8.8.8', 'Google 1', 'External', '0');`
> - Check http://localhost:8080/api/servers if servers from MySQL database running in Docker can be retrieved

<hr/>

<br/>

To set up our database in our Java Spring Application, we need to go to `src/main/resource/application.yml` (Note: `application.properties` can be easily renamed/refactored to `application.yml`):

```yml
# application.yml
spring:
  datasource:
    # MySQL
    url: jdbc:mysql://localhost:3306/pingstatustracker
    username: root
    password: yourpassword
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL5InnoDBDialect
        format_sql: true
```

For the MySQL setup:

- The default port for MySQL is 3306, so the DB address will be `localhost:3306`
- the name of the database will be `pingstatustracker` => the address will be localhost:3306/`pingstatustracker`

The `spring.jpa` section contains configuration settings for JPA (Java Persistence API) and Hibernate, the ORM (Object-Relational Mapping) framework.

-   `show-sql: true` enables logging of SQL statements executed by Hibernate, providing visibility into the generated SQL queries (Note that this should always be disabled in production).
-   `hibernate.ddl-auto:` 
    - `create` specifies that Hibernate should automatically create the database schema based on the entity mappings. This will create the necessary tables when the application starts. Note that this setting is typically used in development and should be handled differently in production.
    - `update` means that Hibernate will update the database schema based on the entity classes' definitions if necesary.
-   `properties.hibernate.dialect` specifies the dialect to use for the MySQL database. In this case, the `org.hibernate.dialect.MySQL5InnoDBDialect` dialect is selected, which is suitable for MySQL version 5 and InnoDB storage engine.
-   `properties.hibernate.format_sql: true` enables the formatting of SQL statements logged by Hibernate, making them more readable for debugging purposes.

<hr/>

We can now create the `pingstatustracker` MySQL database:
-   Open "MySQL 8.0 Command Line Client", write: `create database pingstatustracker;`
-   We can check with `show databases;` command

![Server Database](./SpringBootAngularPingStatusApp/Database01.jpg)

<br/>

We can run the Java Application from Terminal, in the main project directory:

```shell
mvn spring-boot:run
```

<br/>

After running the app, the `Server` table from the `pingstatustracker` database is created automatically in MySQL and can be seen via MySQL Workbench App:
-   On MySQL Workbench -> Click on "Database" from the menu -> "Reverse Engineer(CTRL+B)" -> next, next, next -> Select your schema -> "execute".

![Server Database](./SpringBootAngularPingStatusApp/Database02.jpg)

![Server Database](./SpringBootAngularPingStatusApp/Database03.jpg)

![Server Database](./SpringBootAngularPingStatusApp/Database04.jpg)

![Server Database](./SpringBootAngularPingStatusApp/Database05.jpg)

(Sunday, July 09, 2023, 23:35)

<br/>

Note: We can also interogate (or insert some data into) our MySQL database from the `MySQL 8.0 Command Line Client.exe`:

```sql
show databases;

use pingstatustracker;

show tables;

select * from server;
```

We can insert the following data, where:
- `0` = "SERVER_UP" (Ping success)
- `1` = "SERVER_DOWN" (Ping failed)

```sql
INSERT INTO server (id, ip_address, name, network, status) VALUES (1, '8.8.8.8', 'Google 1', 'External', '0');
INSERT INTO server (id, ip_address, name, network) VALUES (2, '4.4.4.4', 'Google 2', 'External');
INSERT INTO server (id, ip_address, name, network) VALUES (3, '192.168.0.1', 'Server 1', 'Office');
INSERT INTO server (id, ip_address, name) VALUES (4, '192.168.0.3', 'License');
```

- Note: To remove all rows from the server table, effectively deleting all the inserted entries, run `DELETE FROM server;`

<br/>

## Testing with Postman

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 12](https://www.youtube.com/watch?v=A5AebdQACgY&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=12)

You can create an account and download Postman from here: <https://www.postman.com/downloads/>

<br/>

Run the application (`mvn spring-boot:run` in terminal).

ðŸŸ¢ Note that our Java Spring application runs on port `8080` by default (<http://localhost:8080/>). So we can already make a GET request to <http://localhost:8080/api/servers> in our browser (Chrome/Edge/Firefox/etc).

<br/>

In Postman:

ðŸ”µ Send a GET request to <http://localhost:8080/api/servers> (`findAllServers`)

![Server Database](./SpringBootAngularPingStatusApp/Postman01.jpg)

<br/>

ðŸ”µ Send a GET request to <http://localhost:8080/api/servers/<id>> (`findAllServers`)
- http://localhost:8080/api/servers/1
- http://localhost:8080/api/servers/2

![Server Database](./SpringBootAngularPingStatusApp/Postman02.jpg)

<br/>

ðŸ”µ Send a POST request with new Server information
- Open a new tab in Postman with the URL of http://localhost:8080/servers
- Set the request type to POST request
- Click on "Body" subtab
    - check the "raw" radio button
    - select "JSON" format
    - write a JSON without specifying the id (the id will be generated by Spring JPA)

```json
{
    "ipAddress": "192.168.0.2",
    "name": "Default IP",
    "network": "Home",
    "status": null
}
```

Another example:
- for the following JSON

```json
{
    "ipAddress": "192.168.1.1",
    "name": "Linksys",
    "network": "Home",
    "status": null
}
```

- the server will return:

```json
{
    "timeStamp": "2023-07-11T21:26:11.1401562",
    "statusCode": 201,
    "status": "CREATED",
    "message": "Server created",
    "data": {
        "server": {
            "id": 7,
            "ipAddress": "192.168.1.1",
            "name": "Linksys",
            "network": "Home",
            "status": null
        }
    }
}
```

![Server Database](./SpringBootAngularPingStatusApp/Postman_POST01.jpg)

![Server Database](./SpringBootAngularPingStatusApp/Postman_POST02.jpg)

<br/>

ðŸ”µ Send UPDATE request to update a server

- Open a new tab in Postman with the URL of <http://localhost:8080/servers>
- Set the request type to PUT request
- Click on "Body" subtab, check the "raw" radio button, and select "JSON" format
- Instead of this entry (that we currenly have in our database):

```json
"server": {
    "id": 7,
    "ipAddress": "192.168.1.1",
    "name": "Linksys",
    "network": "Home",
    "status": null
}
```

-   We'll send this (where the `name` and `imageUrl` was changed)

```json
{
    "id": 7,
    "ipAddress": "192.168.1.1",
    "name": "Linksys Updated",
    "network": "Home 2",
    "status": null
}
```

![Server Database](./SpringBootAngularPingStatusApp/Postman03.jpg)

<br/>

ðŸ”µ Sent GET request to http://localhost:8080/api/servers/ping/8.8.8.8

![Server Database](./SpringBootAngularPingStatusApp/Postman04.jpg)

<br/>

ðŸ”µ Sent GET request to http://localhost:8080/api/servers/ping/ to ping and retrieve all servers

![Server Database](./SpringBootAngularPingStatusApp/Postman05.jpg)

<br/>

# Frontend Angular

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 13](https://www.youtube.com/watch?v=Bwl2WAsC-8Y&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=13)

We will use [Node.js](https://nodejs.org/en/download) and [Angular CLI](https://angular.io/cli) to create our Front-End Angular Application!

Currently installed on system:

```shell
node --version
# v18.16.1

npm --version
# 9.5.1

ng version
#      _                      _                 ____ _     ___
#     / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
#    / â–³ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
#   / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
#  /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
#                 |___/
#
# Angular CLI: 16.1.4
# Node: 18.16.1
# Package Manager: npm 9.5.1
# OS: win32 x64
# 
# Package                      Version
# ------------------------------------------------------
# @angular-devkit/architect    0.1601.4 (cli-only)
# @angular-devkit/core         16.1.4 (cli-only)
# @angular-devkit/schematics   16.1.4 (cli-only)
# @schematics/angular          16.1.4 (cli-only)
```

(Tuesday, July 11, 2023, 23:42)

<br/>

In main app's folder after installing Node.js:

```shell
# Install the Angular CLI: To install the Angular CLI globally,
# open a terminal window and run the following command
# (You will run this only once):
npm install -g @angular/cli

# To create a new project (a new workspace for an app)
ng new serverpingstatustracker-app

# Change directory
cd serverpingstatustracker-app

# The Angular CLI includes a server, for you to build and serve your app locally
ng serve --open
```

- Would you like to add Angular routing? (y/N): y
- Which stylesheet format would you like to use?: CSS

<br/>

## package.json

```json
// package.json
{
  "name": "serverpingstatustracker-app",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test"
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "^16.1.0",
    "@angular/common": "^16.1.0",
    "@angular/compiler": "^16.1.0",
    "@angular/core": "^16.1.0",
    "@angular/forms": "^16.1.0",
    "@angular/platform-browser": "^16.1.0",
    "@angular/platform-browser-dynamic": "^16.1.0",
    "@angular/router": "^16.1.0",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.13.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^16.1.4",
    "@angular/cli": "~16.1.4",
    "@angular/compiler-cli": "^16.1.0",
    "@types/jasmine": "~4.3.0",
    "jasmine-core": "~4.6.0",
    "karma": "~6.4.0",
    "karma-chrome-launcher": "~3.2.0",
    "karma-coverage": "~2.2.0",
    "karma-jasmine": "~5.1.0",
    "karma-jasmine-html-reporter": "~2.1.0",
    "typescript": "~5.1.3"
  }
}
```

-   `package.json`: this fo;e contains the metadata and configuration for your project, including the dependencies and scripts. It serves as a manifest for your application, specifying what libraries and versions are required.
-   `package-lock.json`: this file is automatically generated by `npm` when you install or update dependencies. It provides a detailed and deterministic description of the dependency tree, including the specific versions of each dependency installed. It ensures that all developers working on the project get the same dependency versions, helping to maintain consistency and avoid dependency conflicts.

Brief explanation of above packages:

1.  rxjs (~7.8.0): RxJS is imported by default in Angular. RxJS is a library for reactive programming (opposite of procedural programming) using Observables, enabling you to work with asynchronous data streams. The version "~7.8.0" indicates that any version starting with 7.8.x is acceptable, allowing minor updates but keeping the major version fixed.

2.  tslib (^2.3.0): tslib is a runtime library for TypeScript that provides helper functions used by the generated JavaScript code. The "^2.3.0" version specifier means that any version equal to or higher than 2.3.0 can be used, allowing both minor and patch updates.

3.  zone.js (~0.13.0): Zone.js is a library that helps with managing asynchronous operations in JavaScript. It provides execution context and hooks into asynchronous operations. The version "~0.13.0" indicates that any version starting with 0.13.x is acceptable, allowing minor updates.

4.  jasmine-core (~4.6.0): Jasmine is a behavior-driven development (BDD) testing framework for JavaScript. It provides a clean and readable syntax for writing tests. The version "~4.6.0" indicates that any version starting with 4.6.x is acceptable, allowing minor updates.

5.  karma (~6.4.0): Karma is a test runner for JavaScript that enables you to execute tests in multiple browsers simultaneously. It provides a simple and consistent way to run tests, capture browsers, and generate test reports. The version "~6.4.0" means that any version starting with 6.4.x is acceptable, allowing minor updates.

6.  karma-chrome-launcher (~3.2.0): Karma Chrome Launcher is a plugin for Karma that launches Google Chrome to run tests in it. The version "~3.2.0" means that any version starting with 3.2.x is acceptable, allowing minor updates.

7.  karma-coverage (~2.2.0): Karma Coverage is a plugin for Karma that generates code coverage reports for your tests, showing how much of your code is covered by tests. The version "~2.2.0" indicates that any version starting with 2.2.x is acceptable, allowing minor updates.

8.  karma-jasmine (~5.1.0): Karma Jasmine is a plugin for Karma that integrates the Jasmine testing framework, allowing you to write and run Jasmine tests using Karma. The version "~5.1.0" means that any version starting with 5.1.x is acceptable, allowing minor updates.

9.  karma-jasmine-html-reporter (~2.1.0): Karma Jasmine HTML Reporter is a plugin for Karma that generates an HTML report with the results of Jasmine tests executed by Karma. The version "~2.1.0" indicates that any version starting with 2.1.x is acceptable, allowing minor updates.

<br/>

## Enums, interfaces, services

### Server status.enum.ts and date-state.enum.ts

First, we can create a folder that will contain all the enumerations within the Angular Project:

- create `./src/app/enum/status.enum.ts`

```ts
// status.enum.ts
export enum Status {
  ALL = 'ALL',
  SERVER_UP = 'SERVER_UP',
  SERVER_DOWN = 'SERVER_DOWN',
}
```

- with `ALL` we will have the option to select (from font-end/UI) all the servers no matter the status - we can then filter the servers based on the SERVER_UP or SERVER_DOWN statuses.

<br/>

- create `./src/app/enum/data-state.enum.ts` that will represent the "Data state" of the data that is in progress to be retrieved

```ts
// data-state.enum.ts
export enum DataState {
  LOADING_STATE = 'LOADING_STATE',
  LOADED_STATE = 'LOADED_STATE',
  ERROR_STATE = 'ERROR_STATE',
}
```

<br/>

### Server and Response interface/model 

- create `./src/app/interface/server.ts`
- define all the attributes that the Server model (in Spring API & database) has:

```ts
// server.ts
import { Status } from '../enum/status.enum';

export interface Server {
  id: number;
  ipAddress: string;
  name: string;
  network: string;
  status: Status;
}
```

<br/>

- create `./src/app/interface/custom-response.ts`
- define all the attributes that the Response model (in Spring API) has:
    - the response that the client gets back from Spring API BackEnd could either have a server or multiple servers as data

```ts
// custom-response.ts
import { Server } from './server';

export interface CustomResponse {
  timeStamp: Date;
  statusCode: number;
  status: string;
  reason: string;
  message: string;
  developerMessage: string;
  data: { servers?: Server[]; server?: Server };
}
```

(Saturday, July 15, 2023)

<br/>

### Application state interface app-state.ts

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 15](https://www.youtube.com/watch?v=4ucfk6znWjM&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=15)

For a reactive approach, we will habe the state of the entire application at any given moment:
- create `./src/app/interface/app-state.ts`
    - the state will be defined from the above enum `enum DataState { LOADING_STATE = 'LOADING_STATE', LOADED_STATE = 'LOADED_STATE', ERROR_STATE = 'ERROR_STATE' }`
    - `appData` will be generic (`<T>`)
    - since we cannot get the data and an error at the same time, `appData?` and `error?` will be both optional 

```ts
// app-state.ts
import { DataState } from '../enum/data-state.enum';

export interface AppState<T> {
  dataState: DataState;
  appData?: T;
  error?: string;
}
```

![Angular Interfaces Enums](./SpringBootAngularPingStatusApp/Angular_Interfaces_Enums.jpg)

<br/>

### Server Angular Service

[Full Stack Spring Boot RESTful API with MySQL and Angular | RxJs State Management - Part 16](https://www.youtube.com/watch?v=4ucfk6znWjM&list=PLopcHtZ0hJF0OIOr88qHuJ3-UKRuCUrKf&index=16)

First, before working on server service, un the Angular's main `/src/app/app.module.ts` we need to import: `import { HttpClientModule } from '@angular/common/http';`, and also add it to the imports array: `imports: [BrowserModule, HttpClientModule],`. ðŸŸ  Note: If we don't import the `HttpClientModule` we will receive the following error from Angular in our browser console: `ERROR NullInjectorError: R3InjectorError(AppModule)[EmployeeService -> HttpClient -> HttpClient -> HttpClient]: NullInjectorError: No provider for HttpClient!`

```ts
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule } from '@angular/common/http';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, AppRoutingModule, HttpClientModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

<br/>

We will now generate the "server" service that will contain all the methods for the HTTP Requests. With Angular's CLI, in the Angular project path, run:

```shell
ng generate service services/server
```

<br/>

In `server.service.ts` we will use Angular's `HttpClient` in order to make HTTP requests (`get`, `post`, `put`, `delete`) that'll be injected in the constructor: `export class ServerService { constructor(private http: HttpClient) {} }`

<br/>

<u>The **procedural approach** of implementing the `ServerService` class that provides methods to interact with the backend API would be the following:</u>

```ts
// server.service.ts - The procedural approach
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { CustomResponse } from '../interfaces/custom-response';

@Injectable({ providedIn: 'root' }) // The Injectable decorator is used to mark the ServerService as a service that can be injected with dependencies. It allows the service to be injected into other components or services.
export class ServerService {
  constructor(private http: HttpClient) {}

  getServers(): Observable<CustomResponse> {
    return this.http.get<CustomResponse>('http://localhost:8080/api/servers');
  }

  getServerById(serverId: number): Observable<CustomResponse> {
    return this.http.get<CustomResponse>(
      `http://localhost:8080/api/servers/${serverId}`
    );
  }

  addServer(server: Server): Observable<Server> {
    const methodName = 'addServer() ';
    console.debug(methodName + 'Request Sent: ' + JSON.stringify(server));
    return this.http.post<Server>(
        `http://localhost:8080/api/servers`, server);
  }
}
```

<br/>

<u>However, we will implement the `ServerService` class using the **reactive approach with RxJS operators**:</u>
-   `servers$ = <Observable<CustomResponse>>...`: declares a property `servers$` of type `Observable<CustomResponse>`. The dollar sign convention (`$`) is a good practice to indicate that this property is an observable.
-   `this.http.get<CustomResponse>(${this.apiUrl}/servers`): makes an HTTP GET request to the API endpoint `${this.apiUrl}/servers` using the `HttpClient` service's `get` method. It expects the response to be of type `CustomResponse`
-   `.pipe(tap(console.log), catchError(this.handleError))`: uses the `pipe` operator to chain multiple operators to the observable. The `tap` operator is used to perform a side effect of logging the response to the console, while the `catchError` operator is used to handle any errors that may occur during the HTTP request.
-   `handleError(handleError: any): Observable<never> { ... }`: This method defines an error handler function named `handleError` which takes an `error` parameter of type `any`. The return type is `Observable<never>`, indicating that it returns an observable that never emits any values. However, in the provided code, the implementation of the `handleError` method is incomplete and throws a `Method not implemented` error when called.

The reactive approach using RxJS operators allows for a more streamlined and declarative way of handling asynchronous operations. It promotes composing and transforming observables using operators, making the code more concise and readable. Operators like `tap` and `catchError` provide powerful ways to perform side effects and error handling within the observable pipeline.

Compared to the procedural approach in the previous example, this reactive approach separates the observable creation and configuration (`servers$`) from the actual usage of the observable. The reactive approach also leverages the power of RxJS operators to handle errors and perform side effects, making it more flexible and easier to manage complex asynchronous flows.

```ts
// server.service.ts - The reactive approach
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, throwError } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';
import { CustomResponse } from '../interfaces/custom-response';

@Injectable({ providedIn: 'root' })
export class ServerService {
  private readonly apiUrl = 'http://localhost:8080/api';

  constructor(private http: HttpClient) {}

  servers$ = <Observable<CustomResponse>>(
    this.http
      .get<CustomResponse>(`${this.apiUrl}/servers`)
      .pipe(tap(console.log), catchError(this.handleError))
  );

  handleError(handleError: any): Observable<never> {
    return throwError('Method not implemented.');
  }
}
```

<br/>

(Monday, July 17, 2023, 22:34)

The complete `server.service.ts` using the reactive approach

```ts
// server.service.ts - The reactive approach | Complete code
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, throwError } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';
import { CustomResponse } from '../interfaces/custom-response';
import { Server } from '../interfaces/server';
import { Status } from '../enums/status.enum';

@Injectable({ providedIn: 'root' })
export class ServerService {
  private readonly apiUrl = 'http://localhost:8080/api';

  constructor(private http: HttpClient) {}

  servers$ = <Observable<CustomResponse>>(
    this.http
      .get<CustomResponse>(`${this.apiUrl}/servers`)
      .pipe(tap(console.log), catchError(this.handleError))
  );

  filter$ = (status: Status, response: CustomResponse) =>
    <Observable<CustomResponse>>new Observable<CustomResponse>((subscriber) => {
      console.log(response);
      const servers = response.data?.servers || [];
      const filteredServers = servers.filter(
        (server) => server.status === status
      );

      const message =
        status === Status.ALL
          ? `Servers filtered by ${status} status`
          : filteredServers.length > 0
          ? `Servers filtered by ${
              status === Status.SERVER_UP ? 'SERVER UP' : 'SERVER DOWN'
            } status`
          : `No servers of ${status} found`;

      subscriber.next({
        ...response,
        message,
        data: {
          servers: filteredServers,
        },
      });
      subscriber.complete();
    }).pipe(tap(console.log), catchError(this.handleError));

  getServerById = (serverId: number) =>
    <Observable<CustomResponse>>(
      this.http
        .get<CustomResponse>(`${this.apiUrl}/servers/${serverId}`)
        .pipe(tap(console.log), catchError(this.handleError))
    );

  addServer$ = (server: Server) =>
    <Observable<CustomResponse>>(
      this.http
        .post<CustomResponse>(`${this.apiUrl}/servers`, server)
        .pipe(tap(console.log), catchError(this.handleError))
    );

  updateServer$ = (server: Server) =>
    <Observable<CustomResponse>>(
      this.http
        .put<CustomResponse>(`${this.apiUrl}/servers`, server)
        .pipe(tap(console.log), catchError(this.handleError))
    );

  deleteServerById = (serverId: number) =>
    <Observable<CustomResponse>>(
      this.http
        .delete<CustomResponse>(`${this.apiUrl}/servers/${serverId}`)
        .pipe(tap(console.log), catchError(this.handleError))
    );

  pingServerById = (serverId: number) =>
    <Observable<CustomResponse>>(
      this.http
        .get<CustomResponse>(`${this.apiUrl}/servers/${serverId}/ping`)
        .pipe(tap(console.log), catchError(this.handleError))
    );

  pingServerByIpAddress = (ipAddress: string) =>
    <Observable<CustomResponse>>(
      this.http
        .get<CustomResponse>(`${this.apiUrl}/servers/ping/${ipAddress}`)
        .pipe(tap(console.log), catchError(this.handleError))
    );

  handleError(error: HttpErrorResponse): Observable<never> {
    console.error(error);
    return throwError(() => new Error(`Error Code: ${error.status}`));
  }
}
```

<br/>

For the `filter$` function that performs filtering on a `CustomResponse` object based on the provided `status` parameter. Here's a breakdown of the function:

1.  `(status: Status, response: CustomResponse) =>`: takes two parameters: `status` of type `Status` and `response` of type `CustomResponse`.
2.  `<Observable<CustomResponse>>new Observable<CustomResponse>((subscriber) => { ... })`: creates a new instance of an observable that emits values of type `CustomResponse`. It takes a subscriber function as an argument.
3.  `const servers = response.data?.servers || [];`: initializes the `servers` variable with the value of `response.data.servers` if it exists; otherwise, it assigns an empty array to `servers`. This guards against `response.data` or `response.data.servers` being `undefined`.
4.  `const filteredServers = servers.filter((server) => server.status === status);`: filters the `servers` array based on the provided `status`, creating a new array `filteredServers` that only contains servers with a matching status.
5.  `const message = ...`: This block assigns the appropriate message based on the conditionals:
    -   If `status` is `Status.ALL`, it sets `message` to `'Servers filtered by ${status} status'`.
    -   If `filteredServers.length` is greater than 0, it sets `message` to `'Servers filtered by SERVER UP status'` or `'Servers filtered by SERVER DOWN status'`.
    -   If none of the above conditions are met, it sets `message` to `'No servers of ${status} found'`.
6.  `subscriber.next({ ... })`: emits a new `CustomResponse` object to the subscriber, which includes the modified `response` object:
    -   The `message` property is updated based on the filtering results.
    -   The `data` property is updated with the filtered servers.
7.  `subscriber.complete();`: signals the completion of the observable stream.
8.  `.pipe(tap(console.log), catchError(this.handleError))`: pipes the observable to apply additional operators:
    -   The `tap(console.log)` operator logs the emitted values to the console.
    -   The `catchError(this.handleError)` operator catches and handles any errors that occur during the observable stream, using the `handleError` method of the `ServerService`.

In summary, the `filter$` function filters servers based on the provided `status` and emits a modified `CustomResponse` object as an observable. The emitted response includes a message indicating the filtering results and the filtered server data.


<br/>

## Demo - Calling GET Servers from app.component.ts

```ts
// app.component.ts
import { Component, OnInit } from '@angular/core';
import { ServerService } from './services/server.service';
import { Observable, catchError, map, of, startWith } from 'rxjs';
import { AppState } from './interfaces/app-state';
import { CustomResponse } from './interfaces/custom-response';
import { DataState } from './enums/data-state.enum';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent implements OnInit {
  appState$!: Observable<AppState<CustomResponse>>;
  constructor(private ServerService: ServerService) {}

  ngOnInit(): void {
    this.appState$ = this.ServerService.getServersPinged$().pipe(
      map((response) => {
        return { dataState: DataState.LOADED_STATE, appData: response };
      }),
      startWith({ dataState: DataState.LOADING_STATE }),
      catchError((error: string) => {
        return of({ dataState: DataState.ERROR_STATE, error });
      })
    );
  }
}
```

```html
<!-- app.component.html -->
<div>{{ appState$ | async | json }}</div>
```


<br/>

### Solving "blocked by CORS policy" - CORS Configuration

Now, if we start the MySQL Server (Start Menu, search and open "Services", manually find MySQL80 service -> Right click it -> Start), and we are also starting the SpringBoot Back-end Server (mvn spring-boot:run and test on http://localhost:8080/api/servers) and the Front-end Angular Application (ng serve --open on http://localhost:4200/), we will run into the following CORS error:

> Access to XMLHttpRequest at 'http://localhost:8080/api/servers/ping' from origin 'http://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.

![CORS example issue](./SpringBootAngularPingStatusApp/CORS_01.jpg)

<br/>

To solve this issue, we need to tell the back-end to allow the front-end app to run on requested url (origin) in order to access the resources.

On the SpringBoot project, in the main application class `ServerpingstatustrackerApplication` we need to add the following CORS Configuration after the `main()` function:

```java
// ServerpingstatustrackerApplication.java
package com.radubulai.serverpingstatustracker;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import java.util.Arrays;

@SpringBootApplication
public class ServerpingstatustrackerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServerpingstatustrackerApplication.class, args);
    }

    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.setAllowCredentials(true);
        corsConfiguration.setAllowedOrigins(Arrays.asList("http://localhost:4200", "http://localhost:8081"));
        corsConfiguration.setAllowedHeaders(Arrays.asList("Origin", "Access-Control-Allow-Origin", "Content-Type",
                "Accept", "Authorization", "Origin, Accept", "X-Requested-With",
                "Access-Control-Request-Method", "Access-Control-Request-Headers"));
        corsConfiguration.setAllowedHeaders(Arrays.asList("Origin", "Content-Type", "Accept", "Authorization",
                "Access-Control-Allow-Origin", "Access-Control-Allow-Credentials"));
        corsConfiguration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();
        urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsFilter(urlBasedCorsConfigurationSource);
    }
}
```

Now we can successfully make requests from frontend:

![CORS example issue](./SpringBootAngularPingStatusApp/CORS_02.jpg)

<br/>